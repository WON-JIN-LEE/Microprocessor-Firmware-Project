
project_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000044  00800100  00000938  000009cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000938  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000034  00800144  00800144  00000a10  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00000a10  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000167  00000000  00000000  00000a50  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000f2b  00000000  00000000  00000bb7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000003d1  00000000  00000000  00001ae2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000b09  00000000  00000000  00001eb3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000180  00000000  00000000  000029bc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000031e  00000000  00000000  00002b3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000500  00000000  00000000  00002e5a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  0000335a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 fc 00 	jmp	0x1f8	; 0x1f8 <__vector_5>
  18:	0c 94 6c 01 	jmp	0x2d8	; 0x2d8 <__vector_6>
  1c:	0c 94 dd 01 	jmp	0x3ba	; 0x3ba <__vector_7>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 87 00 	jmp	0x10e	; 0x10e <__vector_16>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 67 00 	jmp	0xce	; 0xce <__vector_18>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e8 e3       	ldi	r30, 0x38	; 56
  a0:	f9 e0       	ldi	r31, 0x09	; 9
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a4 34       	cpi	r26, 0x44	; 68
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a4 e4       	ldi	r26, 0x44	; 68
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a8 37       	cpi	r26, 0x78	; 120
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 df 02 	call	0x5be	; 0x5be <main>
  c6:	0c 94 9a 04 	jmp	0x934	; 0x934 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <__vector_18>:

} //main 문 


ISR(  USART0_RX_vect )//수신인터럽트
{
  ce:	1f 92       	push	r1
  d0:	0f 92       	push	r0
  d2:	0f b6       	in	r0, 0x3f	; 63
  d4:	0f 92       	push	r0
  d6:	11 24       	eor	r1, r1
  d8:	8f 93       	push	r24

    rdata = UDR0; 
  da:	8c b1       	in	r24, 0x0c	; 12
  dc:	80 93 75 01 	sts	0x0175, r24
 
    SerialPutChar( rdata);           // Echo  수신된 데이터를 바로 송신하여 수신된 데이터가 정확한지 확인 
  e0:	80 91 75 01 	lds	r24, 0x0175
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
  e4:	5d 9b       	sbis	0x0b, 5	; 11
  e6:	fe cf       	rjmp	.-4      	; 0xe4 <__vector_18+0x16>
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
  e8:	8c b9       	out	0x0c, r24	; 12
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
  ea:	5d 9b       	sbis	0x0b, 5	; 11
  ec:	fe cf       	rjmp	.-4      	; 0xea <__vector_18+0x1c>
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
  ee:	8a e0       	ldi	r24, 0x0A	; 10
  f0:	8c b9       	out	0x0c, r24	; 12
    rdata = UDR0; 
 
    SerialPutChar( rdata);           // Echo  수신된 데이터를 바로 송신하여 수신된 데이터가 정확한지 확인 
    SerialPutChar('\n');             // 휴대폰으로 데이터 전송시 Line Feed('\n')를 항상 끝에 전송해야함

    recv_cnt++ ;                     // 수신된 데이터 바이트수 저장
  f2:	80 91 76 01 	lds	r24, 0x0176
  f6:	8f 5f       	subi	r24, 0xFF	; 255
  f8:	80 93 76 01 	sts	0x0176, r24

   new_recv_flag = 1;  
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	80 93 77 01 	sts	0x0177, r24

}
 102:	8f 91       	pop	r24
 104:	0f 90       	pop	r0
 106:	0f be       	out	0x3f, r0	; 63
 108:	0f 90       	pop	r0
 10a:	1f 90       	pop	r1
 10c:	18 95       	reti

0000010e <__vector_16>:




ISR( TIMER0_OVF_vect )    //  10 msec 주기 타이머1 오버플로 인터럽트 서비스프로그램
{
 10e:	1f 92       	push	r1
 110:	0f 92       	push	r0
 112:	0f b6       	in	r0, 0x3f	; 63
 114:	0f 92       	push	r0
 116:	11 24       	eor	r1, r1
 118:	2f 93       	push	r18
 11a:	3f 93       	push	r19
 11c:	8f 93       	push	r24
 11e:	9f 93       	push	r25

    static unsigned short  time_index = 0 ; 


    TCNT0 = 256 - 156;       //  내부클럭주기 = 1024/ (16x10^6) = 64 usec,  
 120:	84 e6       	ldi	r24, 0x64	; 100
 122:	82 bf       	out	0x32, r24	; 50
                             //  오버플로인터럽트 주기 = 10msec
                             //  156 = 10msec/ 64usec


    time_index++ ; 
 124:	80 91 73 01 	lds	r24, 0x0173
 128:	90 91 74 01 	lds	r25, 0x0174
 12c:	01 96       	adiw	r24, 0x01	; 1
 12e:	90 93 74 01 	sts	0x0174, r25
 132:	80 93 73 01 	sts	0x0173, r24


    if( time_index == 5 )   // 50 msec 주기 
 136:	05 97       	sbiw	r24, 0x05	; 5
 138:	09 f0       	breq	.+2      	; 0x13c <__vector_16+0x2e>
 13a:	55 c0       	rjmp	.+170    	; 0x1e6 <__vector_16+0xd8>
    {

       time_index = 0; 
 13c:	10 92 74 01 	sts	0x0174, r1
 140:	10 92 73 01 	sts	0x0173, r1

       sensor_count++;          // 초음파 센서 카운터 값 증가 
 144:	80 91 71 01 	lds	r24, 0x0171
 148:	90 91 72 01 	lds	r25, 0x0172
 14c:	01 96       	adiw	r24, 0x01	; 1
 14e:	90 93 72 01 	sts	0x0172, r25
 152:	80 93 71 01 	sts	0x0171, r24
	       
	 
	   if( sensor_count == 4 )  sensor_count = 1; 
 156:	80 91 71 01 	lds	r24, 0x0171
 15a:	90 91 72 01 	lds	r25, 0x0172
 15e:	04 97       	sbiw	r24, 0x04	; 4
 160:	31 f4       	brne	.+12     	; 0x16e <__vector_16+0x60>
 162:	81 e0       	ldi	r24, 0x01	; 1
 164:	90 e0       	ldi	r25, 0x00	; 0
 166:	90 93 72 01 	sts	0x0172, r25
 16a:	80 93 71 01 	sts	0x0171, r24


       if ( sensor_count == 1 )        //  초음파센서 1 트리거 신호 발생(초음파 1 발사) 
 16e:	80 91 71 01 	lds	r24, 0x0171
 172:	90 91 72 01 	lds	r25, 0x0172
 176:	01 97       	sbiw	r24, 0x01	; 1
 178:	69 f4       	brne	.+26     	; 0x194 <__vector_16+0x86>
	   {
	      PORTB |= 0x01;    // PB0 : High
 17a:	c0 9a       	sbi	0x18, 0	; 24
 17c:	84 e1       	ldi	r24, 0x14	; 20
 17e:	90 e0       	ldi	r25, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 180:	35 e0       	ldi	r19, 0x05	; 5
 182:	23 2f       	mov	r18, r19
 184:	2a 95       	dec	r18
 186:	f1 f7       	brne	.-4      	; 0x184 <__vector_16+0x76>



void usec_delay(int n)
{	
	for(; n>0; n--)		// 1usec 시간 지연을 n회 반복
 188:	01 97       	sbiw	r24, 0x01	; 1
 18a:	d9 f7       	brne	.-10     	; 0x182 <__vector_16+0x74>

       if ( sensor_count == 1 )        //  초음파센서 1 트리거 신호 발생(초음파 1 발사) 
	   {
	      PORTB |= 0x01;    // PB0 : High
		  usec_delay(20) ;  // 20usec 동안 High 유지 
	      PORTB &= 0xFE;    // PB0 : Low 
 18c:	c0 98       	cbi	0x18, 0	; 24
          
		  active_sensor_flag = 1;
 18e:	81 e0       	ldi	r24, 0x01	; 1
 190:	90 e0       	ldi	r25, 0x00	; 0
 192:	25 c0       	rjmp	.+74     	; 0x1de <__vector_16+0xd0>

	   }
       else if ( sensor_count == 2 )   //  초음파센서 2 트리거 신호 발생(초음파 2 발사)
 194:	80 91 71 01 	lds	r24, 0x0171
 198:	90 91 72 01 	lds	r25, 0x0172
 19c:	02 97       	sbiw	r24, 0x02	; 2
 19e:	69 f4       	brne	.+26     	; 0x1ba <__vector_16+0xac>
	   {
	      PORTB |= 0x02;    // PB1 : High
 1a0:	c1 9a       	sbi	0x18, 1	; 24
 1a2:	84 e1       	ldi	r24, 0x14	; 20
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	35 e0       	ldi	r19, 0x05	; 5
 1a8:	23 2f       	mov	r18, r19
 1aa:	2a 95       	dec	r18
 1ac:	f1 f7       	brne	.-4      	; 0x1aa <__vector_16+0x9c>



void usec_delay(int n)
{	
	for(; n>0; n--)		// 1usec 시간 지연을 n회 반복
 1ae:	01 97       	sbiw	r24, 0x01	; 1
 1b0:	d9 f7       	brne	.-10     	; 0x1a8 <__vector_16+0x9a>
	   }
       else if ( sensor_count == 2 )   //  초음파센서 2 트리거 신호 발생(초음파 2 발사)
	   {
	      PORTB |= 0x02;    // PB1 : High
	 	  usec_delay(20) ;  // 20usec 동안 High 유지 
	      PORTB &= 0xFD;    // PB1 : Low 
 1b2:	c1 98       	cbi	0x18, 1	; 24

		  active_sensor_flag = 2;
 1b4:	82 e0       	ldi	r24, 0x02	; 2
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	12 c0       	rjmp	.+36     	; 0x1de <__vector_16+0xd0>

	   }
       else if ( sensor_count == 3 )   //  초음파센서 3 트리거 신호 발생(초음파 3 발사)
 1ba:	80 91 71 01 	lds	r24, 0x0171
 1be:	90 91 72 01 	lds	r25, 0x0172
 1c2:	03 97       	sbiw	r24, 0x03	; 3
 1c4:	81 f4       	brne	.+32     	; 0x1e6 <__vector_16+0xd8>
	   {
	      PORTB |= 0x04;    // PB2 : High
 1c6:	c2 9a       	sbi	0x18, 2	; 24
 1c8:	84 e1       	ldi	r24, 0x14	; 20
 1ca:	90 e0       	ldi	r25, 0x00	; 0
 1cc:	35 e0       	ldi	r19, 0x05	; 5
 1ce:	23 2f       	mov	r18, r19
 1d0:	2a 95       	dec	r18
 1d2:	f1 f7       	brne	.-4      	; 0x1d0 <__vector_16+0xc2>



void usec_delay(int n)
{	
	for(; n>0; n--)		// 1usec 시간 지연을 n회 반복
 1d4:	01 97       	sbiw	r24, 0x01	; 1
 1d6:	d9 f7       	brne	.-10     	; 0x1ce <__vector_16+0xc0>
	   }
       else if ( sensor_count == 3 )   //  초음파센서 3 트리거 신호 발생(초음파 3 발사)
	   {
	      PORTB |= 0x04;    // PB2 : High
		  usec_delay(20) ;  // 20usec 동안 High 유지 
	      PORTB &= 0xFB;    // PB2 : Low 
 1d8:	c2 98       	cbi	0x18, 2	; 24

		  active_sensor_flag = 3;
 1da:	83 e0       	ldi	r24, 0x03	; 3
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	90 93 4c 01 	sts	0x014C, r25
 1e2:	80 93 4b 01 	sts	0x014B, r24


   }


}
 1e6:	9f 91       	pop	r25
 1e8:	8f 91       	pop	r24
 1ea:	3f 91       	pop	r19
 1ec:	2f 91       	pop	r18
 1ee:	0f 90       	pop	r0
 1f0:	0f be       	out	0x3f, r0	; 63
 1f2:	0f 90       	pop	r0
 1f4:	1f 90       	pop	r1
 1f6:	18 95       	reti

000001f8 <__vector_5>:



ISR(INT4_vect)
{
 1f8:	1f 92       	push	r1
 1fa:	0f 92       	push	r0
 1fc:	0f b6       	in	r0, 0x3f	; 63
 1fe:	0f 92       	push	r0
 200:	11 24       	eor	r1, r1
 202:	2f 93       	push	r18
 204:	3f 93       	push	r19
 206:	5f 93       	push	r21
 208:	6f 93       	push	r22
 20a:	7f 93       	push	r23
 20c:	8f 93       	push	r24
 20e:	9f 93       	push	r25
 210:	af 93       	push	r26
 212:	bf 93       	push	r27

    static unsigned short count1 = 0, count2 = 0, del_T = 0, flag = 0 ;

    if ( active_sensor_flag == 1 )
 214:	20 91 4b 01 	lds	r18, 0x014B
 218:	30 91 4c 01 	lds	r19, 0x014C
 21c:	21 30       	cpi	r18, 0x01	; 1
 21e:	31 05       	cpc	r19, r1
 220:	09 f0       	breq	.+2      	; 0x224 <__vector_5+0x2c>
 222:	4c c0       	rjmp	.+152    	; 0x2bc <__vector_5+0xc4>
 	{

	   if(flag == 0) 
 224:	80 91 69 01 	lds	r24, 0x0169
 228:	90 91 6a 01 	lds	r25, 0x016A
 22c:	89 2b       	or	r24, r25
 22e:	69 f4       	brne	.+26     	; 0x24a <__vector_5+0x52>
	   {
		  count1 = TCNT3; 
 230:	80 91 88 00 	lds	r24, 0x0088
 234:	90 91 89 00 	lds	r25, 0x0089
 238:	90 93 70 01 	sts	0x0170, r25
 23c:	80 93 6f 01 	sts	0x016F, r24
		  flag = 1;
 240:	30 93 6a 01 	sts	0x016A, r19
 244:	20 93 69 01 	sts	0x0169, r18
 248:	39 c0       	rjmp	.+114    	; 0x2bc <__vector_5+0xc4>
	  } 
	  else 
	  { 
		  count2 = TCNT3; 
 24a:	80 91 88 00 	lds	r24, 0x0088
 24e:	90 91 89 00 	lds	r25, 0x0089
 252:	90 93 6e 01 	sts	0x016E, r25
 256:	80 93 6d 01 	sts	0x016D, r24
		  del_T = count2 - count1;
 25a:	20 91 6f 01 	lds	r18, 0x016F
 25e:	30 91 70 01 	lds	r19, 0x0170
 262:	82 1b       	sub	r24, r18
 264:	93 0b       	sbc	r25, r19
 266:	90 93 6c 01 	sts	0x016C, r25
 26a:	80 93 6b 01 	sts	0x016B, r24

    	  distance_1 = del_T/(2*58); 
 26e:	64 e7       	ldi	r22, 0x74	; 116
 270:	70 e0       	ldi	r23, 0x00	; 0
 272:	0e 94 86 04 	call	0x90c	; 0x90c <__udivmodhi4>
 276:	70 93 66 01 	sts	0x0166, r23
 27a:	60 93 65 01 	sts	0x0165, r22

          if( distance_1 > 380 )  // 반사되는 초음파가 검출되지 않을때 
 27e:	80 91 65 01 	lds	r24, 0x0165
 282:	90 91 66 01 	lds	r25, 0x0166
 286:	8d 57       	subi	r24, 0x7D	; 125
 288:	91 40       	sbci	r25, 0x01	; 1
 28a:	40 f0       	brcs	.+16     	; 0x29c <__vector_5+0xa4>
		  {
		      distance_1 = distance_1_old ;   // 직전 측정값 사용 
 28c:	80 91 67 01 	lds	r24, 0x0167
 290:	90 91 68 01 	lds	r25, 0x0168
 294:	90 93 66 01 	sts	0x0166, r25
 298:	80 93 65 01 	sts	0x0165, r24
		  } 

          distance_1_old = distance_1 ;    // 직전 측정값 저장 변수 업데이트  
 29c:	80 91 65 01 	lds	r24, 0x0165
 2a0:	90 91 66 01 	lds	r25, 0x0166
 2a4:	90 93 68 01 	sts	0x0168, r25
 2a8:	80 93 67 01 	sts	0x0167, r24

		  flag = 0; 
 2ac:	10 92 6a 01 	sts	0x016A, r1
 2b0:	10 92 69 01 	sts	0x0169, r1

	 	  active_sensor_flag = 0;
 2b4:	10 92 4c 01 	sts	0x014C, r1
 2b8:	10 92 4b 01 	sts	0x014B, r1
	  } 

    }

} 
 2bc:	bf 91       	pop	r27
 2be:	af 91       	pop	r26
 2c0:	9f 91       	pop	r25
 2c2:	8f 91       	pop	r24
 2c4:	7f 91       	pop	r23
 2c6:	6f 91       	pop	r22
 2c8:	5f 91       	pop	r21
 2ca:	3f 91       	pop	r19
 2cc:	2f 91       	pop	r18
 2ce:	0f 90       	pop	r0
 2d0:	0f be       	out	0x3f, r0	; 63
 2d2:	0f 90       	pop	r0
 2d4:	1f 90       	pop	r1
 2d6:	18 95       	reti

000002d8 <__vector_6>:


ISR(INT5_vect)
{
 2d8:	1f 92       	push	r1
 2da:	0f 92       	push	r0
 2dc:	0f b6       	in	r0, 0x3f	; 63
 2de:	0f 92       	push	r0
 2e0:	11 24       	eor	r1, r1
 2e2:	2f 93       	push	r18
 2e4:	3f 93       	push	r19
 2e6:	5f 93       	push	r21
 2e8:	6f 93       	push	r22
 2ea:	7f 93       	push	r23
 2ec:	8f 93       	push	r24
 2ee:	9f 93       	push	r25
 2f0:	af 93       	push	r26
 2f2:	bf 93       	push	r27

    static unsigned short count1 = 0, count2 = 0, del_T = 0, flag = 0 ;


    if ( active_sensor_flag == 2 )
 2f4:	80 91 4b 01 	lds	r24, 0x014B
 2f8:	90 91 4c 01 	lds	r25, 0x014C
 2fc:	02 97       	sbiw	r24, 0x02	; 2
 2fe:	09 f0       	breq	.+2      	; 0x302 <__vector_6+0x2a>
 300:	4e c0       	rjmp	.+156    	; 0x39e <__vector_6+0xc6>
	{

	   if(flag == 0) 
 302:	80 91 5d 01 	lds	r24, 0x015D
 306:	90 91 5e 01 	lds	r25, 0x015E
 30a:	89 2b       	or	r24, r25
 30c:	79 f4       	brne	.+30     	; 0x32c <__vector_6+0x54>
	   {
		  count1 = TCNT3; 
 30e:	80 91 88 00 	lds	r24, 0x0088
 312:	90 91 89 00 	lds	r25, 0x0089
 316:	90 93 64 01 	sts	0x0164, r25
 31a:	80 93 63 01 	sts	0x0163, r24
		  flag = 1;
 31e:	81 e0       	ldi	r24, 0x01	; 1
 320:	90 e0       	ldi	r25, 0x00	; 0
 322:	90 93 5e 01 	sts	0x015E, r25
 326:	80 93 5d 01 	sts	0x015D, r24
 32a:	39 c0       	rjmp	.+114    	; 0x39e <__vector_6+0xc6>
	  } 
	  else 
	  { 
		  count2 = TCNT3; 
 32c:	80 91 88 00 	lds	r24, 0x0088
 330:	90 91 89 00 	lds	r25, 0x0089
 334:	90 93 62 01 	sts	0x0162, r25
 338:	80 93 61 01 	sts	0x0161, r24
		  del_T = count2 - count1;
 33c:	20 91 63 01 	lds	r18, 0x0163
 340:	30 91 64 01 	lds	r19, 0x0164
 344:	82 1b       	sub	r24, r18
 346:	93 0b       	sbc	r25, r19
 348:	90 93 60 01 	sts	0x0160, r25
 34c:	80 93 5f 01 	sts	0x015F, r24
    	  distance_2 = del_T/(2*58); 
 350:	64 e7       	ldi	r22, 0x74	; 116
 352:	70 e0       	ldi	r23, 0x00	; 0
 354:	0e 94 86 04 	call	0x90c	; 0x90c <__udivmodhi4>
 358:	70 93 5a 01 	sts	0x015A, r23
 35c:	60 93 59 01 	sts	0x0159, r22

          if( distance_2 > 380 )  // 반사되는 초음파가 검출되지 않을때 
 360:	80 91 59 01 	lds	r24, 0x0159
 364:	90 91 5a 01 	lds	r25, 0x015A
 368:	8d 57       	subi	r24, 0x7D	; 125
 36a:	91 40       	sbci	r25, 0x01	; 1
 36c:	40 f0       	brcs	.+16     	; 0x37e <__vector_6+0xa6>
		  {
		      distance_2 = distance_2_old ;   // 직전 측정값 사용 
 36e:	80 91 5b 01 	lds	r24, 0x015B
 372:	90 91 5c 01 	lds	r25, 0x015C
 376:	90 93 5a 01 	sts	0x015A, r25
 37a:	80 93 59 01 	sts	0x0159, r24
		  } 

          distance_2_old = distance_2 ;    // 직전 측정값 저장 변수 업데이트  
 37e:	80 91 59 01 	lds	r24, 0x0159
 382:	90 91 5a 01 	lds	r25, 0x015A
 386:	90 93 5c 01 	sts	0x015C, r25
 38a:	80 93 5b 01 	sts	0x015B, r24

		  flag = 0; 
 38e:	10 92 5e 01 	sts	0x015E, r1
 392:	10 92 5d 01 	sts	0x015D, r1

	 	  active_sensor_flag = 0;
 396:	10 92 4c 01 	sts	0x014C, r1
 39a:	10 92 4b 01 	sts	0x014B, r1
	  } 

    }

} 
 39e:	bf 91       	pop	r27
 3a0:	af 91       	pop	r26
 3a2:	9f 91       	pop	r25
 3a4:	8f 91       	pop	r24
 3a6:	7f 91       	pop	r23
 3a8:	6f 91       	pop	r22
 3aa:	5f 91       	pop	r21
 3ac:	3f 91       	pop	r19
 3ae:	2f 91       	pop	r18
 3b0:	0f 90       	pop	r0
 3b2:	0f be       	out	0x3f, r0	; 63
 3b4:	0f 90       	pop	r0
 3b6:	1f 90       	pop	r1
 3b8:	18 95       	reti

000003ba <__vector_7>:



ISR(INT6_vect)
{
 3ba:	1f 92       	push	r1
 3bc:	0f 92       	push	r0
 3be:	0f b6       	in	r0, 0x3f	; 63
 3c0:	0f 92       	push	r0
 3c2:	11 24       	eor	r1, r1
 3c4:	2f 93       	push	r18
 3c6:	3f 93       	push	r19
 3c8:	5f 93       	push	r21
 3ca:	6f 93       	push	r22
 3cc:	7f 93       	push	r23
 3ce:	8f 93       	push	r24
 3d0:	9f 93       	push	r25
 3d2:	af 93       	push	r26
 3d4:	bf 93       	push	r27

    static unsigned short count1 = 0, count2 = 0, del_T = 0, flag = 0 ;

    if ( active_sensor_flag == 3 )
 3d6:	80 91 4b 01 	lds	r24, 0x014B
 3da:	90 91 4c 01 	lds	r25, 0x014C
 3de:	03 97       	sbiw	r24, 0x03	; 3
 3e0:	09 f0       	breq	.+2      	; 0x3e4 <__vector_7+0x2a>
 3e2:	4e c0       	rjmp	.+156    	; 0x480 <__vector_7+0xc6>
	{

	   if(flag == 0) 
 3e4:	80 91 51 01 	lds	r24, 0x0151
 3e8:	90 91 52 01 	lds	r25, 0x0152
 3ec:	89 2b       	or	r24, r25
 3ee:	79 f4       	brne	.+30     	; 0x40e <__vector_7+0x54>
	   {
		  count1 = TCNT3; 
 3f0:	80 91 88 00 	lds	r24, 0x0088
 3f4:	90 91 89 00 	lds	r25, 0x0089
 3f8:	90 93 58 01 	sts	0x0158, r25
 3fc:	80 93 57 01 	sts	0x0157, r24
		  flag = 1;
 400:	81 e0       	ldi	r24, 0x01	; 1
 402:	90 e0       	ldi	r25, 0x00	; 0
 404:	90 93 52 01 	sts	0x0152, r25
 408:	80 93 51 01 	sts	0x0151, r24
 40c:	39 c0       	rjmp	.+114    	; 0x480 <__vector_7+0xc6>
	  } 
	  else 
	  { 
		  count2 = TCNT3; 
 40e:	80 91 88 00 	lds	r24, 0x0088
 412:	90 91 89 00 	lds	r25, 0x0089
 416:	90 93 56 01 	sts	0x0156, r25
 41a:	80 93 55 01 	sts	0x0155, r24
		  del_T = count2 - count1;
 41e:	20 91 57 01 	lds	r18, 0x0157
 422:	30 91 58 01 	lds	r19, 0x0158
 426:	82 1b       	sub	r24, r18
 428:	93 0b       	sbc	r25, r19
 42a:	90 93 54 01 	sts	0x0154, r25
 42e:	80 93 53 01 	sts	0x0153, r24
    	  distance_3 = del_T/(2*58); 
 432:	64 e7       	ldi	r22, 0x74	; 116
 434:	70 e0       	ldi	r23, 0x00	; 0
 436:	0e 94 86 04 	call	0x90c	; 0x90c <__udivmodhi4>
 43a:	70 93 4e 01 	sts	0x014E, r23
 43e:	60 93 4d 01 	sts	0x014D, r22

          if( distance_3 > 380 )  // 반사되는 초음파가 검출되지 않을때 
 442:	80 91 4d 01 	lds	r24, 0x014D
 446:	90 91 4e 01 	lds	r25, 0x014E
 44a:	8d 57       	subi	r24, 0x7D	; 125
 44c:	91 40       	sbci	r25, 0x01	; 1
 44e:	40 f0       	brcs	.+16     	; 0x460 <__vector_7+0xa6>
		  {
		      distance_3 = distance_3_old ;   // 직전 측정값 사용 
 450:	80 91 4f 01 	lds	r24, 0x014F
 454:	90 91 50 01 	lds	r25, 0x0150
 458:	90 93 4e 01 	sts	0x014E, r25
 45c:	80 93 4d 01 	sts	0x014D, r24
		  } 

          distance_3_old = distance_3 ;    // 직전 측정값 저장 변수 업데이트  
 460:	80 91 4d 01 	lds	r24, 0x014D
 464:	90 91 4e 01 	lds	r25, 0x014E
 468:	90 93 50 01 	sts	0x0150, r25
 46c:	80 93 4f 01 	sts	0x014F, r24

		  flag = 0; 
 470:	10 92 52 01 	sts	0x0152, r1
 474:	10 92 51 01 	sts	0x0151, r1

	 	  active_sensor_flag = 0;
 478:	10 92 4c 01 	sts	0x014C, r1
 47c:	10 92 4b 01 	sts	0x014B, r1
	  } 

    }

} 
 480:	bf 91       	pop	r27
 482:	af 91       	pop	r26
 484:	9f 91       	pop	r25
 486:	8f 91       	pop	r24
 488:	7f 91       	pop	r23
 48a:	6f 91       	pop	r22
 48c:	5f 91       	pop	r21
 48e:	3f 91       	pop	r19
 490:	2f 91       	pop	r18
 492:	0f 90       	pop	r0
 494:	0f be       	out	0x3f, r0	; 63
 496:	0f 90       	pop	r0
 498:	1f 90       	pop	r1
 49a:	18 95       	reti

0000049c <init_serial>:

// UART1 통신 초기화 프로그램 

void init_serial(void)
{
    UCSR0A = 0x00;                    //초기화
 49c:	1b b8       	out	0x0b, r1	; 11
    UCSR0B = 0x18  ;                  //송수신허용,  송수신 인터럽트 금지
 49e:	88 e1       	ldi	r24, 0x18	; 24
 4a0:	8a b9       	out	0x0a, r24	; 10
    UCSR0C = 0x06;                    //데이터 전송비트 수 8비트로 설정.
 4a2:	86 e0       	ldi	r24, 0x06	; 6
 4a4:	80 93 95 00 	sts	0x0095, r24
    
    UBRR0H = 0x00;
 4a8:	10 92 90 00 	sts	0x0090, r1
    UBRR0L = 103;                     //Baud Rate 9600 
 4ac:	87 e6       	ldi	r24, 0x67	; 103
 4ae:	89 b9       	out	0x09, r24	; 9
}
 4b0:	08 95       	ret

000004b2 <SerialPutChar>:
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 4b2:	5d 9b       	sbis	0x0b, 5	; 11
 4b4:	fe cf       	rjmp	.-4      	; 0x4b2 <SerialPutChar>
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
 4b6:	8c b9       	out	0x0c, r24	; 12
}
 4b8:	08 95       	ret

000004ba <SerialPutString>:
// 문자열을 송신한다.
// 입력   : str - 송신한 문자열을 저장할 버퍼의 주소
//=============================================

 void SerialPutString(char *str)
 {
 4ba:	fc 01       	movw	r30, r24
 4bc:	04 c0       	rjmp	.+8      	; 0x4c6 <SerialPutString+0xc>
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 4be:	5d 9b       	sbis	0x0b, 5	; 11
 4c0:	fe cf       	rjmp	.-4      	; 0x4be <SerialPutString+0x4>
 {

    while(*str != '\0')         // 수신된 문자가 Null 문자( 0x00 )가 아니면 
    {

        SerialPutChar(*str++);
 4c2:	31 96       	adiw	r30, 0x01	; 1
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
 4c4:	8c b9       	out	0x0c, r24	; 12
//=============================================

 void SerialPutString(char *str)
 {

    while(*str != '\0')         // 수신된 문자가 Null 문자( 0x00 )가 아니면 
 4c6:	80 81       	ld	r24, Z
 4c8:	88 23       	and	r24, r24
 4ca:	c9 f7       	brne	.-14     	; 0x4be <SerialPutString+0x4>
    {

        SerialPutChar(*str++);
    }
}
 4cc:	08 95       	ret

000004ce <HexToDec>:

}


void HexToDec( unsigned short num, unsigned short radix) 
{
 4ce:	0f 93       	push	r16
 4d0:	1f 93       	push	r17
 4d2:	cf 93       	push	r28
 4d4:	df 93       	push	r29
 4d6:	9c 01       	movw	r18, r24
 4d8:	8b 01       	movw	r16, r22
	int j ;

	for(j=0; j<5 ; j++) cnumber[j] = 0 ;
 4da:	10 92 46 01 	sts	0x0146, r1
 4de:	10 92 47 01 	sts	0x0147, r1
 4e2:	10 92 48 01 	sts	0x0148, r1
 4e6:	10 92 49 01 	sts	0x0149, r1
 4ea:	10 92 4a 01 	sts	0x014A, r1
 4ee:	c0 e0       	ldi	r28, 0x00	; 0
 4f0:	d0 e0       	ldi	r29, 0x00	; 0

	j=0;
	do
	{
		cnumber[j++] = num % radix ; 
 4f2:	c9 01       	movw	r24, r18
 4f4:	b8 01       	movw	r22, r16
 4f6:	0e 94 86 04 	call	0x90c	; 0x90c <__udivmodhi4>
 4fa:	fe 01       	movw	r30, r28
 4fc:	ea 5b       	subi	r30, 0xBA	; 186
 4fe:	fe 4f       	sbci	r31, 0xFE	; 254
 500:	80 83       	st	Z, r24
 502:	21 96       	adiw	r28, 0x01	; 1
		num /= radix; 
 504:	c9 01       	movw	r24, r18
 506:	b8 01       	movw	r22, r16
 508:	0e 94 86 04 	call	0x90c	; 0x90c <__udivmodhi4>
 50c:	9b 01       	movw	r18, r22

	} while(num);
 50e:	61 15       	cp	r22, r1
 510:	71 05       	cpc	r23, r1
 512:	79 f7       	brne	.-34     	; 0x4f2 <HexToDec+0x24>

} 
 514:	df 91       	pop	r29
 516:	cf 91       	pop	r28
 518:	1f 91       	pop	r17
 51a:	0f 91       	pop	r16
 51c:	08 95       	ret

0000051e <NumToAsc>:

char NumToAsc( unsigned char Num )
{
	if( Num <10 ) Num += 0x30; 
 51e:	8a 30       	cpi	r24, 0x0A	; 10
 520:	10 f4       	brcc	.+4      	; 0x526 <NumToAsc+0x8>
 522:	80 5d       	subi	r24, 0xD0	; 208
 524:	08 95       	ret
	else          Num += 0x37; 
 526:	89 5c       	subi	r24, 0xC9	; 201

	return Num ;
}
 528:	08 95       	ret

0000052a <msec_delay>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 52a:	20 ea       	ldi	r18, 0xA0	; 160
 52c:	3f e0       	ldi	r19, 0x0F	; 15
 52e:	04 c0       	rjmp	.+8      	; 0x538 <msec_delay+0xe>
 530:	f9 01       	movw	r30, r18
 532:	31 97       	sbiw	r30, 0x01	; 1
 534:	f1 f7       	brne	.-4      	; 0x532 <msec_delay+0x8>



void msec_delay(int n)
{	
	for(; n>0; n--)		// 1msec 시간 지연을 n회 반복
 536:	01 97       	sbiw	r24, 0x01	; 1
 538:	18 16       	cp	r1, r24
 53a:	19 06       	cpc	r1, r25
 53c:	cc f3       	brlt	.-14     	; 0x530 <msec_delay+0x6>
		_delay_ms(1);		// 1msec 시간 지연
}
 53e:	08 95       	ret

00000540 <usec_delay>:
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 540:	35 e0       	ldi	r19, 0x05	; 5
 542:	04 c0       	rjmp	.+8      	; 0x54c <usec_delay+0xc>
 544:	23 2f       	mov	r18, r19
 546:	2a 95       	dec	r18
 548:	f1 f7       	brne	.-4      	; 0x546 <usec_delay+0x6>



void usec_delay(int n)
{	
	for(; n>0; n--)		// 1usec 시간 지연을 n회 반복
 54a:	01 97       	sbiw	r24, 0x01	; 1
 54c:	18 16       	cp	r1, r24
 54e:	19 06       	cpc	r1, r25
 550:	cc f3       	brlt	.-14     	; 0x544 <usec_delay+0x4>
		_delay_us(1);		// 1usec 시간 지연
}
 552:	08 95       	ret

00000554 <Time_Delay_Polling>:

    static unsigned short  curr_delay = 0; 
	unsigned char  ret_val = 0;


    curr_delay++ ;  
 554:	20 91 44 01 	lds	r18, 0x0144
 558:	30 91 45 01 	lds	r19, 0x0145
 55c:	2f 5f       	subi	r18, 0xFF	; 255
 55e:	3f 4f       	sbci	r19, 0xFF	; 255
 560:	30 93 45 01 	sts	0x0145, r19
 564:	20 93 44 01 	sts	0x0144, r18

    if( curr_delay >= d_time )   // 50msec * d_time 경과 후 
 568:	28 17       	cp	r18, r24
 56a:	39 07       	cpc	r19, r25
 56c:	10 f4       	brcc	.+4      	; 0x572 <Time_Delay_Polling+0x1e>
 56e:	80 e0       	ldi	r24, 0x00	; 0
 570:	08 95       	ret
	{
       ret_val = 1; 
       curr_delay = 0 ;
 572:	10 92 45 01 	sts	0x0145, r1
 576:	10 92 44 01 	sts	0x0144, r1
 57a:	81 e0       	ldi	r24, 0x01	; 1


    return  ret_val ;


}
 57c:	08 95       	ret

0000057e <Display_Number_LCD>:


void Display_Number_LCD( unsigned int num )       // 부호없는 정수형 변수를 10진수 형태로 LCD 에 디스플레이 
{

	HexToDec( num, 10); //10진수로 변환
 57e:	6a e0       	ldi	r22, 0x0A	; 10
 580:	70 e0       	ldi	r23, 0x00	; 0
 582:	0e 94 67 02 	call	0x4ce	; 0x4ce <HexToDec>


	LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스필레이 
 586:	80 91 48 01 	lds	r24, 0x0148

} 

char NumToAsc( unsigned char Num )
{
	if( Num <10 ) Num += 0x30; 
 58a:	8a 30       	cpi	r24, 0x0A	; 10
 58c:	10 f4       	brcc	.+4      	; 0x592 <Display_Number_LCD+0x14>
 58e:	80 5d       	subi	r24, 0xD0	; 208
 590:	01 c0       	rjmp	.+2      	; 0x594 <Display_Number_LCD+0x16>
	else          Num += 0x37; 
 592:	89 5c       	subi	r24, 0xC9	; 201
{

	HexToDec( num, 10); //10진수로 변환


	LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스필레이 
 594:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LcdPutchar>

	LcdPutchar(NumToAsc(cnumber[1]));    // 10자리 디스필레이
 598:	80 91 47 01 	lds	r24, 0x0147

} 

char NumToAsc( unsigned char Num )
{
	if( Num <10 ) Num += 0x30; 
 59c:	8a 30       	cpi	r24, 0x0A	; 10
 59e:	10 f4       	brcc	.+4      	; 0x5a4 <Display_Number_LCD+0x26>
 5a0:	80 5d       	subi	r24, 0xD0	; 208
 5a2:	01 c0       	rjmp	.+2      	; 0x5a6 <Display_Number_LCD+0x28>
	else          Num += 0x37; 
 5a4:	89 5c       	subi	r24, 0xC9	; 201
	HexToDec( num, 10); //10진수로 변환


	LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스필레이 

	LcdPutchar(NumToAsc(cnumber[1]));    // 10자리 디스필레이
 5a6:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LcdPutchar>

	LcdPutchar(NumToAsc(cnumber[0]));    //  1자리 디스플레이
 5aa:	80 91 46 01 	lds	r24, 0x0146

} 

char NumToAsc( unsigned char Num )
{
	if( Num <10 ) Num += 0x30; 
 5ae:	8a 30       	cpi	r24, 0x0A	; 10
 5b0:	10 f4       	brcc	.+4      	; 0x5b6 <Display_Number_LCD+0x38>
 5b2:	80 5d       	subi	r24, 0xD0	; 208
 5b4:	01 c0       	rjmp	.+2      	; 0x5b8 <Display_Number_LCD+0x3a>
	else          Num += 0x37; 
 5b6:	89 5c       	subi	r24, 0xC9	; 201

	LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스필레이 

	LcdPutchar(NumToAsc(cnumber[1]));    // 10자리 디스필레이

	LcdPutchar(NumToAsc(cnumber[0]));    //  1자리 디스플레이
 5b8:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LcdPutchar>

}
 5bc:	08 95       	ret

000005be <main>:
               



int main() 
{   
 5be:	ef 92       	push	r14
 5c0:	ff 92       	push	r15
 5c2:	0f 93       	push	r16
 5c4:	1f 93       	push	r17
 5c6:	cf 93       	push	r28
 5c8:	df 93       	push	r29

// UART1 통신 초기화 프로그램 

void init_serial(void)
{
    UCSR0A = 0x00;                    //초기화
 5ca:	1b b8       	out	0x0b, r1	; 11
    UCSR0B = 0x18  ;                  //송수신허용,  송수신 인터럽트 금지
 5cc:	88 e1       	ldi	r24, 0x18	; 24
 5ce:	8a b9       	out	0x0a, r24	; 10
    UCSR0C = 0x06;                    //데이터 전송비트 수 8비트로 설정.
 5d0:	86 e0       	ldi	r24, 0x06	; 6
 5d2:	80 93 95 00 	sts	0x0095, r24
    
    UBRR0H = 0x00;
 5d6:	10 92 90 00 	sts	0x0090, r1
    UBRR0L = 103;                     //Baud Rate 9600 
 5da:	87 e6       	ldi	r24, 0x67	; 103
 5dc:	89 b9       	out	0x09, r24	; 9

unsigned short main_dist1 = 0 ,main_dist2 = 0 ,main_dist3 = 0  ;
/////////////////////////////////
 init_serial() ;    // Serial Port (USART1) 초기화

 UCSR0B |=  0x80  ;      // UART1 송신(RX) 완료 인터럽트 허용
 5de:	57 9a       	sbi	0x0a, 7	; 10
	


///////////////////////////////

	LcdInit();      //  LCd 초기화 함수 
 5e0:	0e 94 5f 04 	call	0x8be	; 0x8be <LcdInit>

	LcdMove(0,0); 
 5e4:	80 e0       	ldi	r24, 0x00	; 0
 5e6:	60 e0       	ldi	r22, 0x00	; 0
 5e8:	0e 94 4f 04 	call	0x89e	; 0x89e <LcdMove>
	LcdPuts("Electric Fan");
 5ec:	80 e0       	ldi	r24, 0x00	; 0
 5ee:	91 e0       	ldi	r25, 0x01	; 1
 5f0:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LcdPuts>

////  3 개의 초음파센서( Ultrasonic Sensor) ////////////

// 출력포트 설정 
	
	DDRB |= 0x07;     // 3 초음파센서 Trigger signals( PB0, PB1, PB2 : 출력포트 설정  )
 5f4:	87 b3       	in	r24, 0x17	; 23
 5f6:	87 60       	ori	r24, 0x07	; 7
 5f8:	87 bb       	out	0x17, r24	; 23
	PORTB &= ~0x07;   // PB0, PB1, PB2  : Low  ( 3 Trigger signals OFF )  
 5fa:	88 b3       	in	r24, 0x18	; 24
 5fc:	88 7f       	andi	r24, 0xF8	; 248
 5fe:	88 bb       	out	0x18, r24	; 24
   
    DDRB |= 0x38;    // PB3,4,5 LED  출력설정 
 600:	87 b3       	in	r24, 0x17	; 23
 602:	88 63       	ori	r24, 0x38	; 56
 604:	87 bb       	out	0x17, r24	; 23
 	PORTB |=0x38;   // 3,4,5, LED off
 606:	88 b3       	in	r24, 0x18	; 24
 608:	88 63       	ori	r24, 0x38	; 56
 60a:	88 bb       	out	0x18, r24	; 24


 ////////////  Timer 0 설정  ( 10 msec 주기 타이머 0 인터럽트 )  ///////////////
        
    TCCR0 = 0x00;            // 타이머 0 정지(분주비 = 1024 ) , Normal mode(타이머모드)
 60c:	13 be       	out	0x33, r1	; 51

    TCNT0 = 256 - 156;       //  내부클럭주기 = 1024/ (16x10^6) = 64 usec,  
 60e:	84 e6       	ldi	r24, 0x64	; 100
 610:	82 bf       	out	0x32, r24	; 50
                             //  오버플로인터럽트 주기 = 10msec
                             //  156 = 10msec/ 64usec

    TIMSK &= ~0x01;            // 타이머0 오버플로인터럽트 금지
 612:	87 b7       	in	r24, 0x37	; 55
 614:	8e 7f       	andi	r24, 0xFE	; 254
 616:	87 bf       	out	0x37, r24	; 55
///////////////////////////////////////////////////////////    


// 3 Echo Signalㄴ Pulse Width measurment,  Timer3 

	TCCR3A = 0x00; 
 618:	10 92 8b 00 	sts	0x008B, r1
	TCCR3B = 0x02;     // 타이머 3 시작(분주비 8) ,  0.5usec 단위로 측정 
 61c:	82 e0       	ldi	r24, 0x02	; 2
 61e:	80 93 8a 00 	sts	0x008A, r24

 
// 3 초음파센서 Echo Signals : external interrupt 4( pin: INT4 (PE4)),  external interrupt 5( pin: INT5 (PE5)) 
//                           : external interrupt 6( pin: INT4 (PE6)) 

	EICRB |= 0x15;    // Both falling edge and rising edge interrupt
 622:	8a b7       	in	r24, 0x3a	; 58
 624:	85 61       	ori	r24, 0x15	; 21
 626:	8a bf       	out	0x3a, r24	; 58
	EICRB &= ~0x2A;   // Both falling edge and rising edge interrupt
 628:	8a b7       	in	r24, 0x3a	; 58
 62a:	85 7d       	andi	r24, 0xD5	; 213
 62c:	8a bf       	out	0x3a, r24	; 58

	EIMSK |= 0x70;    // INT4 Enable, INT5 Enable, INT6 Enable
 62e:	89 b7       	in	r24, 0x39	; 57
 630:	80 67       	ori	r24, 0x70	; 112
 632:	89 bf       	out	0x39, r24	; 57
	sei(); 
 634:	78 94       	sei

///////////////////////////////////////

   //  최초 초음파센서 1 트리거 신호 발생(초음파 1 발사)  
	PORTB |= 0x01;    // PB0 : High
 636:	c0 9a       	sbi	0x18, 0	; 24
 638:	84 e1       	ldi	r24, 0x14	; 20
 63a:	90 e0       	ldi	r25, 0x00	; 0
 63c:	35 e0       	ldi	r19, 0x05	; 5
 63e:	23 2f       	mov	r18, r19
 640:	2a 95       	dec	r18
 642:	f1 f7       	brne	.-4      	; 0x640 <main+0x82>



void usec_delay(int n)
{	
	for(; n>0; n--)		// 1usec 시간 지연을 n회 반복
 644:	01 97       	sbiw	r24, 0x01	; 1
 646:	d9 f7       	brne	.-10     	; 0x63e <main+0x80>
///////////////////////////////////////

   //  최초 초음파센서 1 트리거 신호 발생(초음파 1 발사)  
	PORTB |= 0x01;    // PB0 : High
	usec_delay(20) ;  // 20usec 동안 High 유지 
	PORTB &= 0xFE;    // PB0 : Low 
 648:	c0 98       	cbi	0x18, 0	; 24
          
	active_sensor_flag = 1; 
 64a:	81 e0       	ldi	r24, 0x01	; 1
 64c:	90 e0       	ldi	r25, 0x00	; 0
 64e:	90 93 4c 01 	sts	0x014C, r25
 652:	80 93 4b 01 	sts	0x014B, r24
    sensor_count = 1;
 656:	90 93 72 01 	sts	0x0172, r25
 65a:	80 93 71 01 	sts	0x0171, r24

  /////////////////////////////////////////////


    TCCR0 |= 0x07;    // 타이머 0 시작(분주비 = 1024 ) 
 65e:	83 b7       	in	r24, 0x33	; 51
 660:	87 60       	ori	r24, 0x07	; 7
 662:	83 bf       	out	0x33, r24	; 51
                SerialPutString("cm"); 
				SerialPutChar('\n'); 
 
		  	} 

		   rdata = 0xFF;                           // 수신된 명령을 초기값으로 리셋
 664:	ee 24       	eor	r14, r14
 666:	ea 94       	dec	r14
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
 668:	8a e0       	ldi	r24, 0x0A	; 10
 66a:	f8 2e       	mov	r15, r24
	while (1) 

	{ 


	if( new_recv_flag == 1 )      // 1 문자 수신완료 시 
 66c:	80 91 77 01 	lds	r24, 0x0177
 670:	81 30       	cpi	r24, 0x01	; 1
 672:	09 f0       	breq	.+2      	; 0x676 <main+0xb8>
 674:	54 c0       	rjmp	.+168    	; 0x71e <main+0x160>
		 { 

		  //////////////  명령어 처리   //////////////

			if( rdata == '0' )          // 문자 0 이 수신되면 
 676:	80 91 75 01 	lds	r24, 0x0175
 67a:	80 33       	cpi	r24, 0x30	; 48
 67c:	a9 f4       	brne	.+42     	; 0x6a8 <main+0xea>
			{
				LcdCommand(0x01); //LCD Clear
 67e:	81 e0       	ldi	r24, 0x01	; 1
 680:	0e 94 16 04 	call	0x82c	; 0x82c <LcdCommand>
				LcdMove(0,0); 
 684:	80 e0       	ldi	r24, 0x00	; 0
 686:	60 e0       	ldi	r22, 0x00	; 0
 688:	0e 94 4f 04 	call	0x89e	; 0x89e <LcdMove>
				LcdPuts("Electric Fan OFF");
 68c:	8d e0       	ldi	r24, 0x0D	; 13
 68e:	91 e0       	ldi	r25, 0x01	; 1
 690:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LcdPuts>
              
			   TIMSK &= ~0x01;            // 타이머0 오버플로인터럽트 금지
 694:	87 b7       	in	r24, 0x37	; 55
 696:	8e 7f       	andi	r24, 0xFE	; 254
 698:	87 bf       	out	0x37, r24	; 55

				SerialPutString("Fan Stop"); 
 69a:	8e e1       	ldi	r24, 0x1E	; 30
 69c:	91 e0       	ldi	r25, 0x01	; 1
 69e:	0e 94 5d 02 	call	0x4ba	; 0x4ba <SerialPutString>
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 6a2:	5d 9b       	sbis	0x0b, 5	; 11
 6a4:	fe cf       	rjmp	.-4      	; 0x6a2 <main+0xe4>
 6a6:	36 c0       	rjmp	.+108    	; 0x714 <main+0x156>

				SerialPutString("Fan Stop"); 
				SerialPutChar('\n');
			}

			else if( rdata == '1' )     // 문자 1 이 수신되면
 6a8:	80 91 75 01 	lds	r24, 0x0175
 6ac:	81 33       	cpi	r24, 0x31	; 49
 6ae:	91 f4       	brne	.+36     	; 0x6d4 <main+0x116>
			{
			LcdMove(0,0); 
 6b0:	80 e0       	ldi	r24, 0x00	; 0
 6b2:	60 e0       	ldi	r22, 0x00	; 0
 6b4:	0e 94 4f 04 	call	0x89e	; 0x89e <LcdMove>
			LcdPuts("Electric Fan ON");
 6b8:	87 e2       	ldi	r24, 0x27	; 39
 6ba:	91 e0       	ldi	r25, 0x01	; 1
 6bc:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LcdPuts>

            TIMSK |= 0x01;           // 타이머0 오버플로인터럽트 허용
 6c0:	87 b7       	in	r24, 0x37	; 55
 6c2:	81 60       	ori	r24, 0x01	; 1
 6c4:	87 bf       	out	0x37, r24	; 55
			SerialPutString("Fan Start"); 
 6c6:	87 e3       	ldi	r24, 0x37	; 55
 6c8:	91 e0       	ldi	r25, 0x01	; 1
 6ca:	0e 94 5d 02 	call	0x4ba	; 0x4ba <SerialPutString>
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 6ce:	5d 9b       	sbis	0x0b, 5	; 11
 6d0:	fe cf       	rjmp	.-4      	; 0x6ce <main+0x110>
 6d2:	20 c0       	rjmp	.+64     	; 0x714 <main+0x156>
            TIMSK |= 0x01;           // 타이머0 오버플로인터럽트 허용
			SerialPutString("Fan Start"); 
			SerialPutChar('\n'); 
			}

			else if( rdata == '2')      
 6d4:	80 91 75 01 	lds	r24, 0x0175
 6d8:	82 33       	cpi	r24, 0x32	; 50
 6da:	39 f4       	brne	.+14     	; 0x6ea <main+0x12c>
			{
			//PWM 약

               
                SerialPutString("cm"); 
 6dc:	81 e4       	ldi	r24, 0x41	; 65
 6de:	91 e0       	ldi	r25, 0x01	; 1
 6e0:	0e 94 5d 02 	call	0x4ba	; 0x4ba <SerialPutString>
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 6e4:	5d 9b       	sbis	0x0b, 5	; 11
 6e6:	fe cf       	rjmp	.-4      	; 0x6e4 <main+0x126>
 6e8:	15 c0       	rjmp	.+42     	; 0x714 <main+0x156>
               
                SerialPutString("cm"); 
				SerialPutChar('\n');                    
		                       
			} 
			else if( rdata == '3')      
 6ea:	80 91 75 01 	lds	r24, 0x0175
 6ee:	83 33       	cpi	r24, 0x33	; 51
 6f0:	39 f4       	brne	.+14     	; 0x700 <main+0x142>
			{
			//PWM 중간
                SerialPutString("cm"); 
 6f2:	81 e4       	ldi	r24, 0x41	; 65
 6f4:	91 e0       	ldi	r25, 0x01	; 1
 6f6:	0e 94 5d 02 	call	0x4ba	; 0x4ba <SerialPutString>
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 6fa:	5d 9b       	sbis	0x0b, 5	; 11
 6fc:	fe cf       	rjmp	.-4      	; 0x6fa <main+0x13c>
 6fe:	0a c0       	rjmp	.+20     	; 0x714 <main+0x156>
			//PWM 중간
                SerialPutString("cm"); 
				SerialPutChar('\n'); 
		        
			} 
			else if( rdata == '4')      
 700:	80 91 75 01 	lds	r24, 0x0175
 704:	84 33       	cpi	r24, 0x34	; 52
 706:	39 f4       	brne	.+14     	; 0x716 <main+0x158>
			{

		   //PWM 강
                SerialPutString("cm"); 
 708:	81 e4       	ldi	r24, 0x41	; 65
 70a:	91 e0       	ldi	r25, 0x01	; 1
 70c:	0e 94 5d 02 	call	0x4ba	; 0x4ba <SerialPutString>
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 710:	5d 9b       	sbis	0x0b, 5	; 11
 712:	fe cf       	rjmp	.-4      	; 0x710 <main+0x152>
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
 714:	fc b8       	out	0x0c, r15	; 12
                SerialPutString("cm"); 
				SerialPutChar('\n'); 
 
		  	} 

		   rdata = 0xFF;                           // 수신된 명령을 초기값으로 리셋
 716:	e0 92 75 01 	sts	0x0175, r14
           new_recv_flag = 0;                   
 71a:	10 92 77 01 	sts	0x0177, r1
  

       }
    //////////////////////////////////////////////////

	cli();
 71e:	f8 94       	cli
 	    main_dist1 = distance_1 ;
 720:	00 91 65 01 	lds	r16, 0x0165
 724:	10 91 66 01 	lds	r17, 0x0166
		main_dist2 = distance_2 ;
 728:	c0 91 59 01 	lds	r28, 0x0159
 72c:	d0 91 5a 01 	lds	r29, 0x015A
		main_dist3 = distance_3 ;
 730:	80 91 4d 01 	lds	r24, 0x014D
 734:	90 91 4e 01 	lds	r25, 0x014E
 	sei(); 
 738:	78 94       	sei
	
		if(main_dist1<=20 && main_dist2<=20 && main_dist3<=20)//20cm보다 작으면
 73a:	05 31       	cpi	r16, 0x15	; 21
 73c:	11 05       	cpc	r17, r1
 73e:	98 f4       	brcc	.+38     	; 0x766 <main+0x1a8>
 740:	c5 31       	cpi	r28, 0x15	; 21
 742:	d1 05       	cpc	r29, r1
 744:	50 f4       	brcc	.+20     	; 0x75a <main+0x19c>
 746:	45 97       	sbiw	r24, 0x15	; 21
 748:	18 f4       	brcc	.+6      	; 0x750 <main+0x192>
		{
		PORTB &=~0x38; //LED on
 74a:	88 b3       	in	r24, 0x18	; 24
 74c:	87 7c       	andi	r24, 0xC7	; 199
 74e:	03 c0       	rjmp	.+6      	; 0x756 <main+0x198>
		
		}
		else if (main_dist1<=20 && main_dist2<=20){
		PORTB |=0x20; //LED off pb5
 750:	c5 9a       	sbi	0x18, 5	; 24
		PORTB &=~0x18; //LED on pb3,4
 752:	88 b3       	in	r24, 0x18	; 24
 754:	87 7e       	andi	r24, 0xE7	; 231
 756:	88 bb       	out	0x18, r24	; 24
 758:	21 c0       	rjmp	.+66     	; 0x79c <main+0x1de>
		
		}
		else if (main_dist1<=20 && main_dist3<=20){
 75a:	45 97       	sbiw	r24, 0x15	; 21
 75c:	68 f4       	brcc	.+26     	; 0x778 <main+0x1ba>
		PORTB |=0x10; //LED off pb4
 75e:	c4 9a       	sbi	0x18, 4	; 24
		PORTB &=~0x28; //LED on pb3,5
 760:	88 b3       	in	r24, 0x18	; 24
 762:	87 7d       	andi	r24, 0xD7	; 215
 764:	f8 cf       	rjmp	.-16     	; 0x756 <main+0x198>
		}
		else if (main_dist2<=20 && main_dist3<=20){
 766:	c5 31       	cpi	r28, 0x15	; 21
 768:	d1 05       	cpc	r29, r1
 76a:	80 f4       	brcc	.+32     	; 0x78c <main+0x1ce>
 76c:	45 97       	sbiw	r24, 0x15	; 21
 76e:	48 f4       	brcc	.+18     	; 0x782 <main+0x1c4>
		PORTB |=0x08; //LED off pb3
 770:	c3 9a       	sbi	0x18, 3	; 24
		PORTB &=~0x30; //LED on pb4,5
 772:	88 b3       	in	r24, 0x18	; 24
 774:	8f 7c       	andi	r24, 0xCF	; 207
 776:	ef cf       	rjmp	.-34     	; 0x756 <main+0x198>
		}
		else if (main_dist1<=20 ){
		PORTB |=0x30; //LED off pb 4,5
 778:	88 b3       	in	r24, 0x18	; 24
 77a:	80 63       	ori	r24, 0x30	; 48
 77c:	88 bb       	out	0x18, r24	; 24
		PORTB &=~0x08; //LED on pb3
 77e:	c3 98       	cbi	0x18, 3	; 24
 780:	0d c0       	rjmp	.+26     	; 0x79c <main+0x1de>

		}
		else if (main_dist2<=20){
		PORTB |=0x28; //LED off pb 3,5
 782:	88 b3       	in	r24, 0x18	; 24
 784:	88 62       	ori	r24, 0x28	; 40
 786:	88 bb       	out	0x18, r24	; 24
		PORTB &=~0x10; //LED on pb4
 788:	c4 98       	cbi	0x18, 4	; 24
 78a:	08 c0       	rjmp	.+16     	; 0x79c <main+0x1de>

		}
		else if (main_dist3<=20){
 78c:	45 97       	sbiw	r24, 0x15	; 21
 78e:	28 f4       	brcc	.+10     	; 0x79a <main+0x1dc>
		PORTB |=0x18; //LED off pb 3,4
 790:	88 b3       	in	r24, 0x18	; 24
 792:	88 61       	ori	r24, 0x18	; 24
 794:	88 bb       	out	0x18, r24	; 24
		PORTB &=~0x20; //LED on pb5
 796:	c5 98       	cbi	0x18, 5	; 24
 798:	01 c0       	rjmp	.+2      	; 0x79c <main+0x1de>

		}

		else{
			PORTB |=0x08; //LED off
 79a:	c3 9a       	sbi	0x18, 3	; 24



     

	LcdMove(0,9); 
 79c:	80 e0       	ldi	r24, 0x00	; 0
 79e:	69 e0       	ldi	r22, 0x09	; 9
 7a0:	0e 94 4f 04 	call	0x89e	; 0x89e <LcdMove>
	 Display_Number_LCD(main_dist1);
 7a4:	c8 01       	movw	r24, r16
 7a6:	0e 94 bf 02 	call	0x57e	; 0x57e <Display_Number_LCD>
	LcdMove(1,9); 
 7aa:	81 e0       	ldi	r24, 0x01	; 1
 7ac:	69 e0       	ldi	r22, 0x09	; 9
 7ae:	0e 94 4f 04 	call	0x89e	; 0x89e <LcdMove>
	 Display_Number_LCD(main_dist2);
 7b2:	ce 01       	movw	r24, r28
 7b4:	0e 94 bf 02 	call	0x57e	; 0x57e <Display_Number_LCD>
 7b8:	59 cf       	rjmp	.-334    	; 0x66c <main+0xae>

000007ba <LcdPutchar>:
 7ba:	95 e3       	ldi	r25, 0x35	; 53
 7bc:	29 2f       	mov	r18, r25
 7be:	2a 95       	dec	r18
 7c0:	f1 f7       	brne	.-4      	; 0x7be <LcdPutchar+0x4>

static void write_data(char ch)
{
	unsigned char temp;

	temp = (ch & 0xF0) | 0x05;
 7c2:	29 2f       	mov	r18, r25
 7c4:	2a 95       	dec	r18
 7c6:	f1 f7       	brne	.-4      	; 0x7c4 <LcdPutchar+0xa>
 7c8:	29 2f       	mov	r18, r25
 7ca:	2a 95       	dec	r18
 7cc:	f1 f7       	brne	.-4      	; 0x7ca <LcdPutchar+0x10>
 7ce:	29 2f       	mov	r18, r25
 7d0:	2a 95       	dec	r18
 7d2:	f1 f7       	brne	.-4      	; 0x7d0 <LcdPutchar+0x16>
 7d4:	9a 95       	dec	r25
 7d6:	f1 f7       	brne	.-4      	; 0x7d4 <LcdPutchar+0x1a>
 7d8:	98 2f       	mov	r25, r24
 7da:	90 7f       	andi	r25, 0xF0	; 240
 7dc:	95 60       	ori	r25, 0x05	; 5

	LCD_PORT = temp;
 7de:	95 bb       	out	0x15, r25	; 21
	LCD_PORT = temp & ~0x04;
 7e0:	9b 7f       	andi	r25, 0xFB	; 251
 7e2:	95 bb       	out	0x15, r25	; 21

	temp = (ch<<4) | 0x05;
 7e4:	82 95       	swap	r24
 7e6:	80 7f       	andi	r24, 0xF0	; 240
 7e8:	85 60       	ori	r24, 0x05	; 5

	LCD_PORT = temp;
 7ea:	85 bb       	out	0x15, r24	; 21
	LCD_PORT = temp & ~0x04;
 7ec:	8b 7f       	andi	r24, 0xFB	; 251
 7ee:	85 bb       	out	0x15, r24	; 21

void LcdPutchar(char ch)
{
	checkbusy();
	write_data(ch);
}
 7f0:	08 95       	ret

000007f2 <LcdPuts>:

void LcdPuts(char* str)
{
 7f2:	cf 93       	push	r28
 7f4:	df 93       	push	r29
 7f6:	ec 01       	movw	r28, r24
 7f8:	03 c0       	rjmp	.+6      	; 0x800 <LcdPuts+0xe>
   while(*str)
  {
   LcdPutchar(*str);
 7fa:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LcdPutchar>
   str++;
 7fe:	21 96       	adiw	r28, 0x01	; 1
	write_data(ch);
}

void LcdPuts(char* str)
{
   while(*str)
 800:	88 81       	ld	r24, Y
 802:	88 23       	and	r24, r24
 804:	d1 f7       	brne	.-12     	; 0x7fa <LcdPuts+0x8>
  {
   LcdPutchar(*str);
   str++;
  }
}
 806:	df 91       	pop	r29
 808:	cf 91       	pop	r28
 80a:	08 95       	ret

0000080c <write_command>:

static void write_command(char command)

{
  char temp;
  temp = (command & 0xF0)|0x04;
 80c:	98 2f       	mov	r25, r24
 80e:	90 7f       	andi	r25, 0xF0	; 240
 810:	94 60       	ori	r25, 0x04	; 4

LCD_PORT = temp;
 812:	95 bb       	out	0x15, r25	; 21
LCD_PORT = temp & ~0x04;
 814:	9b 7f       	andi	r25, 0xFB	; 251
 816:	95 bb       	out	0x15, r25	; 21

temp = (command << 4) | 0x04;
 818:	82 95       	swap	r24
 81a:	80 7f       	andi	r24, 0xF0	; 240
 81c:	84 60       	ori	r24, 0x04	; 4

LCD_PORT = temp;
 81e:	85 bb       	out	0x15, r24	; 21
LCD_PORT = temp & ~0x04;
 820:	8b 7f       	andi	r24, 0xFB	; 251
 822:	85 bb       	out	0x15, r24	; 21
 824:	85 e0       	ldi	r24, 0x05	; 5
 826:	8a 95       	dec	r24
 828:	f1 f7       	brne	.-4      	; 0x826 <write_command+0x1a>
_delay_us(1);
}
 82a:	08 95       	ret

0000082c <LcdCommand>:
	LcdCommand(ENTMOD);

	LcdCommand(DISP_ON);
}
void LcdCommand(char command)
{
 82c:	1f 93       	push	r17
 82e:	18 2f       	mov	r17, r24
 830:	85 e3       	ldi	r24, 0x35	; 53
 832:	98 2f       	mov	r25, r24
 834:	9a 95       	dec	r25
 836:	f1 f7       	brne	.-4      	; 0x834 <LcdCommand+0x8>
	checkbusy();
	write_command(command);
 838:	98 2f       	mov	r25, r24
 83a:	9a 95       	dec	r25
 83c:	f1 f7       	brne	.-4      	; 0x83a <LcdCommand+0xe>
 83e:	98 2f       	mov	r25, r24
 840:	9a 95       	dec	r25
 842:	f1 f7       	brne	.-4      	; 0x840 <LcdCommand+0x14>
 844:	98 2f       	mov	r25, r24
 846:	9a 95       	dec	r25
 848:	f1 f7       	brne	.-4      	; 0x846 <LcdCommand+0x1a>
 84a:	8a 95       	dec	r24
 84c:	f1 f7       	brne	.-4      	; 0x84a <LcdCommand+0x1e>
 84e:	81 2f       	mov	r24, r17
 850:	0e 94 06 04 	call	0x80c	; 0x80c <write_command>
	if(command==ALLCLR || command==HOME)
 854:	11 50       	subi	r17, 0x01	; 1
 856:	12 30       	cpi	r17, 0x02	; 2
 858:	20 f4       	brcc	.+8      	; 0x862 <LcdCommand+0x36>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 85a:	80 e4       	ldi	r24, 0x40	; 64
 85c:	9f e1       	ldi	r25, 0x1F	; 31
 85e:	01 97       	sbiw	r24, 0x01	; 1
 860:	f1 f7       	brne	.-4      	; 0x85e <LcdCommand+0x32>
		_delay_ms(2);
}
 862:	1f 91       	pop	r17
 864:	08 95       	ret

00000866 <LcdNewchar>:
  LcdCommand(pos);
}


void LcdNewchar(char ch, char font[])
{
 866:	0f 93       	push	r16
 868:	1f 93       	push	r17
 86a:	cf 93       	push	r28
 86c:	df 93       	push	r29
 86e:	8b 01       	movw	r16, r22
 int i;

 ch <<=3;
 870:	88 0f       	add	r24, r24
 872:	88 0f       	add	r24, r24
 874:	88 0f       	add	r24, r24
 ch|= 0x40;

 LcdCommand(ch);
 876:	80 64       	ori	r24, 0x40	; 64
 878:	0e 94 16 04 	call	0x82c	; 0x82c <LcdCommand>
 87c:	c0 e0       	ldi	r28, 0x00	; 0
 87e:	d0 e0       	ldi	r29, 0x00	; 0

 for(i=0;i<8;i++)
    LcdPutchar(font[i]);
 880:	f8 01       	movw	r30, r16
 882:	ec 0f       	add	r30, r28
 884:	fd 1f       	adc	r31, r29
 886:	80 81       	ld	r24, Z
 888:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LcdPutchar>
 ch <<=3;
 ch|= 0x40;

 LcdCommand(ch);

 for(i=0;i<8;i++)
 88c:	21 96       	adiw	r28, 0x01	; 1
 88e:	c8 30       	cpi	r28, 0x08	; 8
 890:	d1 05       	cpc	r29, r1
 892:	b1 f7       	brne	.-20     	; 0x880 <LcdNewchar+0x1a>
    LcdPutchar(font[i]);
}
 894:	df 91       	pop	r29
 896:	cf 91       	pop	r28
 898:	1f 91       	pop	r17
 89a:	0f 91       	pop	r16
 89c:	08 95       	ret

0000089e <LcdMove>:

{ 

//  pos = (line << 6) + pos; 

	if(line == 0 )       pos = 0x00 + pos ;
 89e:	88 23       	and	r24, r24
 8a0:	49 f0       	breq	.+18     	; 0x8b4 <LcdMove+0x16>
	else if( line == 1 ) pos = 0x40 + pos ;
 8a2:	81 30       	cpi	r24, 0x01	; 1
 8a4:	11 f4       	brne	.+4      	; 0x8aa <LcdMove+0xc>
 8a6:	60 5c       	subi	r22, 0xC0	; 192
 8a8:	05 c0       	rjmp	.+10     	; 0x8b4 <LcdMove+0x16>
	else if( line == 2 ) pos = 0x10 + pos ;
 8aa:	82 30       	cpi	r24, 0x02	; 2
 8ac:	11 f4       	brne	.+4      	; 0x8b2 <LcdMove+0x14>
 8ae:	60 5f       	subi	r22, 0xF0	; 240
 8b0:	01 c0       	rjmp	.+2      	; 0x8b4 <LcdMove+0x16>
	else                 pos = 0x50 + pos ;
 8b2:	60 5b       	subi	r22, 0xB0	; 176

  pos |= 0x80;
 
  LcdCommand(pos);
 8b4:	86 2f       	mov	r24, r22
 8b6:	80 68       	ori	r24, 0x80	; 128
 8b8:	0e 94 16 04 	call	0x82c	; 0x82c <LcdCommand>
}
 8bc:	08 95       	ret

000008be <LcdInit>:
static void write_command(char command);
static void write_data(char ch);

void LcdInit(void)
{
	LCD_DDR = 0xff;
 8be:	8f ef       	ldi	r24, 0xFF	; 255
 8c0:	84 bb       	out	0x14, r24	; 20
 8c2:	80 e6       	ldi	r24, 0x60	; 96
 8c4:	9a ee       	ldi	r25, 0xEA	; 234
 8c6:	01 97       	sbiw	r24, 0x01	; 1
 8c8:	f1 f7       	brne	.-4      	; 0x8c6 <LcdInit+0x8>
	_delay_ms(15);
	write_command(0x30);
 8ca:	80 e3       	ldi	r24, 0x30	; 48
 8cc:	0e 94 06 04 	call	0x80c	; 0x80c <write_command>
 8d0:	80 e2       	ldi	r24, 0x20	; 32
 8d2:	9e e4       	ldi	r25, 0x4E	; 78
 8d4:	01 97       	sbiw	r24, 0x01	; 1
 8d6:	f1 f7       	brne	.-4      	; 0x8d4 <LcdInit+0x16>
	_delay_ms(5);
	write_command(0x30);
 8d8:	80 e3       	ldi	r24, 0x30	; 48
 8da:	0e 94 06 04 	call	0x80c	; 0x80c <write_command>
 8de:	80 ea       	ldi	r24, 0xA0	; 160
 8e0:	9f e0       	ldi	r25, 0x0F	; 15
 8e2:	01 97       	sbiw	r24, 0x01	; 1
 8e4:	f1 f7       	brne	.-4      	; 0x8e2 <LcdInit+0x24>
	_delay_ms(1);
	write_command(0x32);
 8e6:	82 e3       	ldi	r24, 0x32	; 50
 8e8:	0e 94 06 04 	call	0x80c	; 0x80c <write_command>

	LcdCommand(FUNSET);
 8ec:	88 e2       	ldi	r24, 0x28	; 40
 8ee:	0e 94 16 04 	call	0x82c	; 0x82c <LcdCommand>
	LcdCommand(DISP_OFF);
 8f2:	88 e0       	ldi	r24, 0x08	; 8
 8f4:	0e 94 16 04 	call	0x82c	; 0x82c <LcdCommand>
	LcdCommand(ALLCLR);
 8f8:	81 e0       	ldi	r24, 0x01	; 1
 8fa:	0e 94 16 04 	call	0x82c	; 0x82c <LcdCommand>
	LcdCommand(ENTMOD);
 8fe:	86 e0       	ldi	r24, 0x06	; 6
 900:	0e 94 16 04 	call	0x82c	; 0x82c <LcdCommand>

	LcdCommand(DISP_ON);
 904:	8c e0       	ldi	r24, 0x0C	; 12
 906:	0e 94 16 04 	call	0x82c	; 0x82c <LcdCommand>
}
 90a:	08 95       	ret

0000090c <__udivmodhi4>:
 90c:	aa 1b       	sub	r26, r26
 90e:	bb 1b       	sub	r27, r27
 910:	51 e1       	ldi	r21, 0x11	; 17
 912:	07 c0       	rjmp	.+14     	; 0x922 <__udivmodhi4_ep>

00000914 <__udivmodhi4_loop>:
 914:	aa 1f       	adc	r26, r26
 916:	bb 1f       	adc	r27, r27
 918:	a6 17       	cp	r26, r22
 91a:	b7 07       	cpc	r27, r23
 91c:	10 f0       	brcs	.+4      	; 0x922 <__udivmodhi4_ep>
 91e:	a6 1b       	sub	r26, r22
 920:	b7 0b       	sbc	r27, r23

00000922 <__udivmodhi4_ep>:
 922:	88 1f       	adc	r24, r24
 924:	99 1f       	adc	r25, r25
 926:	5a 95       	dec	r21
 928:	a9 f7       	brne	.-22     	; 0x914 <__udivmodhi4_loop>
 92a:	80 95       	com	r24
 92c:	90 95       	com	r25
 92e:	bc 01       	movw	r22, r24
 930:	cd 01       	movw	r24, r26
 932:	08 95       	ret

00000934 <_exit>:
 934:	f8 94       	cli

00000936 <__stop_program>:
 936:	ff cf       	rjmp	.-2      	; 0x936 <__stop_program>
